<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout - Robinsons Game Arcade</title>
    <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>üß± Breakout</h1>
            <a href="../../index.html" class="back-btn">‚Üê Back to Games</a>
        </div>

        <canvas id="gameCanvas" class="game-canvas" width="480" height="400"></canvas>

        <div class="game-info">
            <div class="info-box">
                <label>Score</label>
                <span id="score">0</span>
            </div>
            <div class="info-box">
                <label>Level</label>
                <span id="level">1</span>
            </div>
            <div class="info-box">
                <label>Lives</label>
                <span id="lives">3</span>
            </div>
        </div>

        <div class="game-controls">
            <button id="startBtn" class="game-btn">Start Game</button>
            <button id="pauseBtn" class="game-btn secondary" style="display:none;">Pause</button>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <p>Use ‚Üê ‚Üí arrow keys or mouse to move the paddle. Break all the bricks to advance to the next level!</p>
        </div>
    </div>

    <style>
        @media (max-width: 520px) {
            #gameCanvas {
                width: 100%;
                height: auto;
            }
        }
    </style>

    <script>
        // Polyfill for roundRect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives');

        // Game constants
        const PADDLE_WIDTH = 80;
        const PADDLE_HEIGHT = 12;
        const BALL_RADIUS = 6;
        const BRICK_ROWS = 5;
        const BRICK_COLS = 8;
        const BRICK_WIDTH = 54;
        const BRICK_HEIGHT = 18;
        const BRICK_PADDING = 4;
        const BRICK_OFFSET_TOP = 40;
        const BRICK_OFFSET_LEFT = 8;

        // Game state
        let paddle = { x: 0, width: PADDLE_WIDTH };
        let ball = { x: 0, y: 0, dx: 0, dy: 0 };
        let bricks = [];
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameLoop = null;
        let isRunning = false;
        let isPaused = false;

        // Colors for bricks by row
        const BRICK_COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'];

        function initBricks() {
            bricks = [];
            for (let r = 0; r < BRICK_ROWS; r++) {
                bricks[r] = [];
                for (let c = 0; c < BRICK_COLS; c++) {
                    bricks[r][c] = { 
                        x: 0, 
                        y: 0, 
                        status: 1,
                        hits: level > 2 && r === 0 ? 2 : 1  // Top row takes 2 hits on higher levels
                    };
                }
            }
        }

        function resetBall() {
            paddle.x = (canvas.width - PADDLE_WIDTH) / 2;
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 40;
            const speed = 4 + level * 0.5;
            const angle = (Math.random() * Math.PI / 3) + Math.PI / 3; // 60-120 degrees up
            ball.dx = speed * Math.cos(angle) * (Math.random() < 0.5 ? 1 : -1);
            ball.dy = -speed * Math.sin(angle);
        }

        function drawPaddle() {
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.roundRect(paddle.x, canvas.height - 20, paddle.width, PADDLE_HEIGHT, 5);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(paddle.x + 5, canvas.height - 19, paddle.width - 10, 3);
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            
            // Shine
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
        }

        function drawBricks() {
            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLS; c++) {
                    const brick = bricks[r][c];
                    if (brick.status > 0) {
                        const brickX = c * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT;
                        const brickY = r * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP;
                        brick.x = brickX;
                        brick.y = brickY;

                        ctx.fillStyle = brick.hits > 1 ? '#64748b' : BRICK_COLORS[r];
                        ctx.beginPath();
                        ctx.roundRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT, 3);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(brickX + 2, brickY + 2, BRICK_WIDTH - 4, 4);
                    }
                }
            }
        }

        function collisionDetection() {
            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLS; c++) {
                    const brick = bricks[r][c];
                    if (brick.status > 0) {
                        if (ball.x + BALL_RADIUS > brick.x &&
                            ball.x - BALL_RADIUS < brick.x + BRICK_WIDTH &&
                            ball.y + BALL_RADIUS > brick.y &&
                            ball.y - BALL_RADIUS < brick.y + BRICK_HEIGHT) {
                            
                            brick.hits--;
                            if (brick.hits <= 0) {
                                brick.status = 0;
                            }
                            
                            ball.dy = -ball.dy;
                            score += 10 * level;
                            scoreEl.textContent = score;

                            // Check if all bricks are destroyed
                            if (checkWin()) {
                                nextLevel();
                            }
                        }
                    }
                }
            }
        }

        function checkWin() {
            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLS; c++) {
                    if (bricks[r][c].status > 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function nextLevel() {
            level++;
            levelEl.textContent = level;
            initBricks();
            resetBall();
            
            // Show level message
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#10b981';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Level ${level}!`, canvas.width / 2, canvas.height / 2);
            
            isPaused = true;
            setTimeout(() => {
                isPaused = false;
            }, 1500);
        }

        function update() {
            // Ball movement
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collision
            if (ball.x + BALL_RADIUS > canvas.width || ball.x - BALL_RADIUS < 0) {
                ball.dx = -ball.dx;
            }
            if (ball.y - BALL_RADIUS < 0) {
                ball.dy = -ball.dy;
            }

            // Paddle collision
            if (ball.y + BALL_RADIUS > canvas.height - 20 &&
                ball.x > paddle.x &&
                ball.x < paddle.x + paddle.width) {
                
                // Adjust angle based on where ball hits paddle
                const hitPos = (ball.x - paddle.x) / paddle.width;
                const angle = (hitPos - 0.5) * Math.PI / 3;
                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx = speed * Math.sin(angle);
                ball.dy = -Math.abs(speed * Math.cos(angle));
            }

            // Ball out of bounds
            if (ball.y + BALL_RADIUS > canvas.height) {
                lives--;
                livesEl.textContent = lives;
                
                if (lives <= 0) {
                    gameOver();
                } else {
                    resetBall();
                }
            }

            collisionDetection();
        }

        function draw() {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBricks();
            drawPaddle();
            drawBall();
        }

        function gameStep() {
            if (!isRunning || isPaused) return;
            update();
            draw();
            gameLoop = requestAnimationFrame(gameStep);
        }

        function startGame() {
            score = 0;
            lives = 3;
            level = 1;
            scoreEl.textContent = '0';
            livesEl.textContent = '3';
            levelEl.textContent = '1';
            
            initBricks();
            resetBall();
            
            isRunning = true;
            isPaused = false;
            startBtn.style.display = 'none';
            pauseBtn.style.display = 'inline-block';
            
            gameLoop = requestAnimationFrame(gameStep);
        }

        function pauseGame() {
            if (!isRunning) return;
            
            if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = 'Pause';
                gameLoop = requestAnimationFrame(gameStep);
            } else {
                isPaused = true;
                pauseBtn.textContent = 'Resume';
                cancelAnimationFrame(gameLoop);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        function gameOver() {
            isRunning = false;
            cancelAnimationFrame(gameLoop);
            startBtn.style.display = 'inline-block';
            startBtn.textContent = 'Play Again';
            pauseBtn.style.display = 'none';

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ef4444';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
        }

        // Keyboard controls
        let leftPressed = false;
        let rightPressed = false;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = true;
                e.preventDefault();
            }
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = true;
                e.preventDefault();
            }
            if (e.key === ' ') {
                if (!isRunning) startGame();
                else pauseGame();
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = false;
            }
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = false;
            }
        });

        // Update paddle position in game loop
        setInterval(() => {
            if (!isRunning || isPaused) return;
            const speed = 8;
            if (leftPressed && paddle.x > 0) {
                paddle.x -= speed;
            }
            if (rightPressed && paddle.x < canvas.width - paddle.width) {
                paddle.x += speed;
            }
        }, 16);

        // Mouse/touch controls
        canvas.addEventListener('mousemove', (e) => {
            if (!isRunning || isPaused) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;
            paddle.x = Math.min(Math.max(mouseX - paddle.width / 2, 0), canvas.width - paddle.width);
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!isRunning || isPaused) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touchX = (e.touches[0].clientX - rect.left) * scaleX;
            paddle.x = Math.min(Math.max(touchX - paddle.width / 2, 0), canvas.width - paddle.width);
            e.preventDefault();
        });

        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', pauseGame);

        // Initial draw
        paddle.x = (canvas.width - PADDLE_WIDTH) / 2;
        initBricks();
        resetBall();
        draw();
    </script>
</body>
</html>
